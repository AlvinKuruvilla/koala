//! CSS Inline Layout and Line Box Model.
//!
//! [§ 9.4.2 Inline formatting contexts](https://www.w3.org/TR/CSS2/visuren.html#inline-formatting)
//!
//! "In an inline formatting context, boxes are laid out horizontally, one
//! after the other, beginning at the top of a containing block. Horizontal
//! margins, borders, and padding are respected between these boxes."
//!
//! [§ 10.8 Line height calculations: the 'line-height' and 'vertical-align' properties](https://www.w3.org/TR/CSS2/visudet.html#line-height)
//!
//! "The height of the line box is determined by the rules given in the
//! section on line height calculations."

use super::box_model::Rect;

/// [§ 9.4.2 Inline formatting contexts](https://www.w3.org/TR/CSS2/visuren.html#inline-formatting)
///
/// "The rectangular area that contains the boxes that form a line is called
/// a line box."
///
/// "The width of a line box is determined by a containing block and the
/// presence of floats."
///
/// "The height of a line box is determined by the rules given in the
/// section on line height calculations."
#[derive(Debug, Clone)]
pub struct LineBox {
    /// The bounding rectangle of this line box.
    pub bounds: Rect,

    /// Fragments laid out on this line.
    pub fragments: Vec<LineFragment>,

    /// [§ 10.8 Line height calculations](https://www.w3.org/TR/CSS2/visudet.html#line-height)
    ///
    /// "The height of the line box is the distance between the uppermost
    /// box top and the lowermost box bottom."
    pub line_height: f32,

    /// The baseline position relative to the line box top.
    ///
    /// [§ 10.8.1 Leading and half-leading](https://www.w3.org/TR/CSS2/visudet.html#leading)
    ///
    /// "CSS assumes that every font has font metrics that specify a
    /// characteristic height above the baseline and a depth below it."
    pub baseline: f32,
}

/// A fragment of content placed on a line.
///
/// [§ 9.2.1.1 Anonymous inline boxes](https://www.w3.org/TR/CSS2/visuren.html#anonymous-inline)
///
/// "When an inline box contains an in-flow block-level box, the inline box
/// (and its inline ancestors within the same line box) are broken around
/// the block-level box... splitting it into two boxes."
///
/// A fragment represents a piece of an inline box that has been placed on
/// a specific line. One inline box may produce multiple fragments if it
/// wraps across lines.
#[derive(Debug, Clone)]
pub struct LineFragment {
    /// The position and size of this fragment on the line.
    pub bounds: Rect,

    /// The content of this fragment.
    pub content: FragmentContent,

    /// [§ 10.8 Line height calculations](https://www.w3.org/TR/CSS2/visudet.html#line-height)
    ///
    /// "The 'vertical-align' property affects the vertical positioning
    /// inside a line box of the boxes generated by an inline-level element."
    pub vertical_align: VerticalAlign,
}

/// The content of a line fragment.
#[derive(Debug, Clone)]
pub enum FragmentContent {
    /// A run of text.
    Text(TextRun),
    /// An inline-level box (e.g., `<span>`, `<a>`).
    InlineBox,
    /// A replaced inline element (e.g., `<img>`).
    ReplacedElement,
}

/// A contiguous run of text within a line fragment.
///
/// [§ 2.5 Text Runs](https://www.w3.org/TR/css-display-3/#text-nodes)
///
/// "A text run is a maximal sequence of consecutive text nodes."
#[derive(Debug, Clone)]
pub struct TextRun {
    /// The text content of this run.
    pub text: String,
    /// The width of this text run in pixels (computed from font metrics).
    pub width: f32,
    /// Font size in pixels.
    pub font_size: f32,
}

/// [§ 10.8.1 Leading and half-leading](https://www.w3.org/TR/CSS2/visudet.html#leading)
///
/// "The 'vertical-align' property affects the vertical positioning inside
/// a line box of the boxes generated by an inline-level element."
///
/// "Values for this property have different meanings in the context of
/// tables. Please consult the section on vertical alignment in tables
/// for details."
///
/// "Values (for inline elements) have the following meanings:
///
/// baseline
///   Align the baseline of the box with the baseline of the parent box.
///
/// middle
///   Align the vertical midpoint of the box with the baseline of the
///   parent box plus half the x-height of the parent.
///
/// sub
///   Lower the baseline of the box to the proper position for subscripts.
///
/// super
///   Raise the baseline of the box to the proper position for superscripts.
///
/// text-top
///   Align the top of the box with the top of the parent's content area.
///
/// text-bottom
///   Align the bottom of the box with the bottom of the parent's content area.
///
/// top
///   Align the top of the aligned subtree with the top of the line box.
///
/// bottom
///   Align the bottom of the aligned subtree with the bottom of the line box.
///
/// <percentage>
///   Raise (positive) or lower (negative) the box by this distance
///   (a percentage of the 'line-height' value).
///
/// <length>
///   Raise (positive) or lower (negative) the box by this distance."
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum VerticalAlign {
    /// "Align the baseline of the box with the baseline of the parent box."
    Baseline,
    /// "Align the vertical midpoint of the box with the baseline plus half x-height."
    Middle,
    /// "Lower the baseline of the box for subscripts."
    Sub,
    /// "Raise the baseline of the box for superscripts."
    Super,
    /// "Align the top with the top of the parent's content area."
    TextTop,
    /// "Align the bottom with the bottom of the parent's content area."
    TextBottom,
    /// "Align the top of the aligned subtree with the top of the line box."
    Top,
    /// "Align the bottom of the aligned subtree with the bottom of the line box."
    Bottom,
    /// Offset from baseline by a specific pixel amount.
    Length(f32),
}

impl Default for VerticalAlign {
    fn default() -> Self {
        VerticalAlign::Baseline
    }
}

/// Inline formatting context that manages line box construction.
///
/// [§ 9.4.2 Inline formatting contexts](https://www.w3.org/TR/CSS2/visuren.html#inline-formatting)
///
/// "In an inline formatting context, boxes are laid out horizontally, one
/// after the other, beginning at the top of a containing block."
pub struct InlineLayout {
    /// Completed line boxes.
    pub line_boxes: Vec<LineBox>,
    /// Fragments accumulating on the current line.
    pub current_line_fragments: Vec<LineFragment>,
    /// Current X position on the current line.
    pub current_x: f32,
    /// Current line's Y position (top of line box).
    pub current_y: f32,
    /// Maximum width available for line boxes.
    pub available_width: f32,
    /// Maximum height seen on the current line (for line box height).
    pub current_line_max_height: f32,
}

impl InlineLayout {
    /// Create a new inline layout context.
    pub fn new(available_width: f32, start_y: f32) -> Self {
        InlineLayout {
            line_boxes: Vec::new(),
            current_line_fragments: Vec::new(),
            current_x: 0.0,
            current_y: start_y,
            available_width,
            current_line_max_height: 0.0,
        }
    }

    /// [§ 9.4.2](https://www.w3.org/TR/CSS2/visuren.html#inline-formatting)
    ///
    /// Add a text run to the inline formatting context.
    ///
    /// "In an inline formatting context, boxes are laid out horizontally, one
    /// after the other, beginning at the top of a containing block."
    ///
    /// "When an inline box exceeds the width of a line box, it is split into
    /// several boxes and these boxes are distributed across several line boxes."
    ///
    /// TODO: Implement text layout:
    ///
    /// STEP 1: Measure the text width
    ///   // Use font metrics to calculate the pixel width of the text.
    ///   // [§ 10.8 Line height calculations](https://www.w3.org/TR/CSS2/visudet.html#line-height)
    ///   // The height contribution is determined by line-height.
    ///
    /// STEP 2: Check if text fits on the current line
    ///   // if self.current_x + text_width > self.available_width {
    ///   //     // Need to break the text
    ///   // }
    ///
    /// STEP 3: Handle line breaking
    ///   // [§ 5.5.1 Line Breaking Details](https://www.w3.org/TR/css-text-3/#line-breaking)
    ///   // "A line break is forced at a preserved newline."
    ///   //
    ///   // [§ 5.5.2 Word Breaking Rules](https://www.w3.org/TR/css-text-3/#word-breaking)
    ///   // Find the last soft wrap opportunity before the line end.
    ///   // Soft wrap opportunities occur at:
    ///   //   - Whitespace characters (per white-space property)
    ///   //   - Before and after CJK characters
    ///   //   - At hyphens
    ///
    /// STEP 4: Place fragment(s) on line(s)
    ///   // Create LineFragment for each piece of text.
    ///   // If text was split, finalize current line and start new one.
    ///
    /// STEP 5: Update current position
    ///   // self.current_x += fragment_width;
    ///   // self.current_line_max_height = max(height, self.current_line_max_height);
    pub fn add_text(&mut self, _text: &str, _font_size: f32) {
        todo!("Layout text within inline formatting context per CSS 2.1 § 9.4.2")
    }

    /// [§ 9.4.2](https://www.w3.org/TR/CSS2/visuren.html#inline-formatting)
    ///
    /// Add an inline-level box (e.g., `<span>`) to the current line.
    ///
    /// "Horizontal margins, borders, and padding are respected between
    /// inline boxes."
    ///
    /// "The boxes may be aligned vertically in different ways: their bottoms
    /// or tops may be aligned, or the baselines of text within them may be
    /// aligned."
    ///
    /// TODO: Implement inline box layout:
    ///
    /// STEP 1: Calculate the inline box's margin box width
    ///   // inline_width = margin_left + border_left + padding_left
    ///   //              + content_width
    ///   //              + padding_right + border_right + margin_right
    ///
    /// STEP 2: Check if box fits on current line
    ///   // If not, call self.finish_line() to start a new line
    ///
    /// STEP 3: Recursively layout the inline box's contents
    ///   // The inline box may contain text runs and other inline boxes
    ///
    /// STEP 4: Create fragment and position it
    ///   // fragment.bounds.x = self.current_x;
    ///   // self.current_x += inline_width;
    pub fn add_inline_box(&mut self, _width: f32, _height: f32) {
        todo!("Layout inline box within inline formatting context per CSS 2.1 § 9.4.2")
    }

    /// [§ 10.8 Line height calculations](https://www.w3.org/TR/CSS2/visudet.html#line-height)
    ///
    /// Finalize the current line box and start a new one.
    ///
    /// "The height of the line box is the distance between the uppermost box
    /// top and the lowermost box bottom."
    ///
    /// [§ 16.2 Alignment: the 'text-align' property](https://www.w3.org/TR/CSS2/text.html#alignment-prop)
    ///
    /// "This property describes how inline-level content of a block container
    /// is aligned."
    ///
    /// TODO: Implement line finalization:
    ///
    /// STEP 1: Calculate line box height
    ///   // [§ 10.8.1](https://www.w3.org/TR/CSS2/visudet.html#leading)
    ///   // "The height of the line box is the distance between the uppermost
    ///   //  box top and the lowermost box bottom."
    ///   // height = max(fragment heights after vertical alignment)
    ///
    /// STEP 2: Calculate baseline position
    ///   // Find the baseline from font metrics of the strut
    ///   // (the imaginary zero-width inline box with the element's font)
    ///
    /// STEP 3: Apply vertical alignment
    ///   // [§ 10.8.1](https://www.w3.org/TR/CSS2/visudet.html#leading)
    ///   // For each fragment, adjust y position based on vertical-align value.
    ///   // baseline → align baseline with line baseline
    ///   // top → align fragment top with line box top
    ///   // bottom → align fragment bottom with line box bottom
    ///   // middle → align midpoint with baseline + half x-height
    ///
    /// STEP 4: Apply text-align
    ///   // [§ 16.2](https://www.w3.org/TR/CSS2/text.html#alignment-prop)
    ///   // "left": fragments start at left edge (default for LTR)
    ///   // "right": fragments are flush right
    ///   // "center": fragments are centered
    ///   // "justify": extra space distributed between words
    ///   // let remaining = self.available_width - total_fragment_width;
    ///   // Apply offset based on text-align value.
    ///
    /// STEP 5: Create line box and advance Y
    ///   // let line_box = LineBox { bounds, fragments, line_height, baseline };
    ///   // self.line_boxes.push(line_box);
    ///   // self.current_y += line_height;
    ///   // self.current_x = 0.0;
    ///   // self.current_line_fragments.clear();
    pub fn finish_line(&mut self) {
        todo!("Finalize current line box per CSS 2.1 § 10.8")
    }

    /// [§ 5.5 Line Breaking and Word Boundaries](https://www.w3.org/TR/css-text-3/#line-breaking)
    ///
    /// Find the last soft wrap opportunity in a text string that fits
    /// within the given width.
    ///
    /// "A soft wrap opportunity is a position in the text where the
    /// UA may choose to break."
    ///
    /// [§ 5.5.2 Breaking Rules](https://www.w3.org/TR/css-text-3/#word-breaking)
    ///
    /// "When determining line breaks:
    ///
    /// - A sequence of collapsible spaces at the end of a line is removed.
    /// - A soft wrap opportunity exists at the boundary of whitespace.
    /// - A soft wrap opportunity exists before and after CJK characters."
    ///
    /// TODO: Implement word breaking:
    ///
    /// STEP 1: Find all soft wrap opportunities
    ///   // Scan for whitespace boundaries, hyphens, CJK characters
    ///
    /// STEP 2: Find the last opportunity that fits
    ///   // Measure text width from start to each opportunity
    ///   // Return the last one where width <= max_width
    ///
    /// STEP 3: Handle overflow-wrap: break-word
    ///   // [§ 3.3 overflow-wrap](https://www.w3.org/TR/css-text-3/#overflow-wrap-property)
    ///   // "If the word is too long to fit on a line by itself, break at
    ///   //  an arbitrary point."
    pub fn find_break_opportunity(_text: &str, _max_width: f32, _font_size: f32) -> Option<usize> {
        todo!("Find line break opportunity per CSS Text Module § 5.5")
    }

    /// Return the total height consumed by all completed line boxes.
    ///
    /// [§ 10.6.1 Inline, non-replaced elements](https://www.w3.org/TR/CSS2/visudet.html#inline-non-replaced)
    ///
    /// "The 'height' property does not apply. The height of the content area
    /// should be based on the font, but this specification does not specify how."
    pub fn total_height(&self) -> f32 {
        self.line_boxes
            .iter()
            .map(|lb| lb.line_height)
            .sum()
    }
}
