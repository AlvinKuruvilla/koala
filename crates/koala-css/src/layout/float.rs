//! CSS Float Layout.
//!
//! [§ 9.5 Floats](https://www.w3.org/TR/CSS2/visuren.html#floats)
//!
//! "A float is a box that is shifted to the left or right on the current line.
//! The most interesting characteristic of a float is that content may flow along
//! its side (or be prohibited from doing so by the 'clear' property)."
//!
//! "A floated box is shifted to the left or right until its outer edge touches
//! the containing block edge or the outer edge of another float."

use super::box_model::Rect;

/// [§ 9.5 Floats](https://www.w3.org/TR/CSS2/visuren.html#floats)
///
/// "Values have the following meanings:
///
/// left
///   The element generates a block box that is floated to the left.
///
/// right
///   The element generates a block box that is floated to the right.
///
/// none
///   The box is not floated."
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FloatSide {
    /// "The element generates a block box that is floated to the left."
    Left,
    /// "The element generates a block box that is floated to the right."
    Right,
}

/// [§ 9.5.2 Controlling flow next to floats: the 'clear' property](https://www.w3.org/TR/CSS2/visuren.html#flow-control)
///
/// "This property indicates which sides of an element's box(es) may not
/// be adjacent to an earlier floating box."
///
/// "Values have the following meanings:
///
/// left
///   Requires that the top border edge of the box be below the bottom
///   outer edge of any left-floating boxes.
///
/// right
///   Requires that the top border edge of the box be below the bottom
///   outer edge of any right-floating boxes.
///
/// both
///   Requires that the top border edge of the box be below the bottom
///   outer edge of any right-floating and left-floating boxes.
///
/// none
///   No constraint on the box's position with respect to floats."
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ClearSide {
    /// "Requires the top border edge be below any left-floating boxes."
    Left,
    /// "Requires the top border edge be below any right-floating boxes."
    Right,
    /// "Requires the top border edge be below any floating boxes."
    Both,
}

/// A single float that has been placed in the flow.
///
/// [§ 9.5 Floats](https://www.w3.org/TR/CSS2/visuren.html#floats)
#[derive(Debug, Clone)]
pub struct PlacedFloat {
    /// Which side this float is on.
    pub side: FloatSide,
    /// The margin box of the float (absolute coordinates).
    pub margin_box: Rect,
}

/// Tracks placed floats within a block formatting context.
///
/// [§ 9.5 Floats](https://www.w3.org/TR/CSS2/visuren.html#floats)
///
/// "Since a float is not in the flow, non-positioned block boxes created
/// before and after the float box flow vertically as if the float did not
/// exist. However, the current and subsequent line boxes created next to
/// the float are shortened as necessary to make room for the margin box
/// of the float."
pub struct FloatContext {
    /// All left floats that have been placed.
    pub left_floats: Vec<PlacedFloat>,
    /// All right floats that have been placed.
    pub right_floats: Vec<PlacedFloat>,
    /// Width of the containing block.
    pub containing_width: f32,
}

impl FloatContext {
    /// Create a new float context for a containing block.
    #[must_use]
    pub const fn new(containing_width: f32) -> Self {
        Self {
            left_floats: Vec::new(),
            right_floats: Vec::new(),
            containing_width,
        }
    }

    /// [§ 9.5.1 Positioning the float: the 'float' property](https://www.w3.org/TR/CSS2/visuren.html#float-position)
    ///
    /// Place a float within this context.
    ///
    /// "A floated box is shifted to the left or right until its outer edge
    /// touches the containing block edge or the outer edge of another float."
    ///
    /// The spec defines 9 precise rules for float placement:
    ///
    /// TODO: Implement float placement:
    ///
    /// STEP 1: Apply rule 1
    ///   // "The left outer edge of a left-floating box may not be to the
    ///   //  left of the left edge of its containing block."
    ///   // (Analogous rule for right floats.)
    ///
    /// STEP 2: Apply rule 2
    ///   // "If the current box is left-floating, and there are any
    ///   //  left-floating boxes generated by elements earlier in the
    ///   //  source document, then... the left outer edge of the current
    ///   //  box must be to the right of the right outer edge of every
    ///   //  such earlier box, or its top must be lower."
    ///
    /// STEP 3: Apply rule 3
    ///   // "The right outer edge of a left-floating box may not be to the
    ///   //  right of the left outer edge of any right-floating box that
    ///   //  is to the right of it."
    ///
    /// STEP 4: Apply rule 4
    ///   // "A floating box's outer top may not be higher than the top of
    ///   //  its containing block."
    ///
    /// STEP 5: Apply rule 5
    ///   // "The outer top of a floating box may not be higher than the
    ///   //  outer top of any block or floated box generated by an element
    ///   //  earlier in the source document."
    ///
    /// STEP 6: Apply rule 6
    ///   // "The outer top of an element's floating box may not be higher
    ///   //  than the top of any line-box containing a box generated by an
    ///   //  element earlier in the source document."
    ///
    /// STEP 7: Apply rule 7
    ///   // "A left-floating box that has another left-floating box to its
    ///   //  left may not have its right outer edge to the right of its
    ///   //  containing block's right edge."
    ///
    /// STEP 8: Apply rule 8
    ///   // "A floating box must be placed as high as possible."
    ///
    /// STEP 9: Apply rule 9
    ///   // "A left-floating box must be put as far to the left as possible,
    ///   //  a right-floating box as far to the right as possible. A higher
    ///   //  position is preferred over one that is further to the left/right."
    pub fn place_float(
        &mut self,
        _side: FloatSide,
        _box_width: f32,
        _box_height: f32,
        _current_y: f32,
    ) -> Rect {
        todo!("Place a float according to CSS 2.1 § 9.5.1 rules 1-9")
    }

    /// [§ 9.5.2 Controlling flow next to floats: the 'clear' property](https://www.w3.org/TR/CSS2/visuren.html#flow-control)
    ///
    /// "This property indicates which sides of an element's box(es) may not
    /// be adjacent to an earlier floating box."
    ///
    /// "Computing the clearance of an element on which 'clear' is set is done
    /// by first determining the hypothetical position of the element's top
    /// border edge within its parent block... if this hypothetical position
    /// is not past the relevant floats, then clearance is introduced, and
    /// margins collapse according to the rules in 8.3.1."
    ///
    /// TODO: Implement clearance:
    ///
    /// STEP 1: Find the lowest float on the cleared side(s)
    ///   // For clear: left → find max bottom edge of all left floats
    ///   // For clear: right → find max bottom edge of all right floats
    ///   // For clear: both → find max of both
    ///
    /// STEP 2: Compute clearance
    ///   // `clearance = max(0, lowest_float_bottom - hypothetical_top)`
    ///
    /// STEP 3: Return the new Y position
    ///   // `new_y = hypothetical_top + clearance`
    #[must_use]
    pub fn clear(&self, _clear_side: ClearSide, _current_y: f32) -> f32 {
        todo!("Compute clearance for clear property per CSS 2.1 § 9.5.2")
    }

    /// [§ 9.5 Floats](https://www.w3.org/TR/CSS2/visuren.html#floats)
    ///
    /// "The current and subsequent line boxes created next to the float are
    /// shortened as necessary to make room for the margin box of the float."
    ///
    /// Returns the available width for content at a given Y position,
    /// accounting for floats on both sides.
    ///
    /// TODO: Implement available width calculation:
    ///
    /// STEP 1: Find all active floats at the given Y position
    ///   // A float is "active" at Y if:
    ///   //   `float.margin_box.y <= y < float.margin_box.y + float.margin_box.height`
    ///
    /// STEP 2: Calculate left intrusion
    ///   // `left_edge = max(float.margin_box.x + float.margin_box.width)`
    ///   //             for all active left floats
    ///
    /// STEP 3: Calculate right intrusion
    ///   // `right_edge = min(float.margin_box.x)`
    ///   //              for all active right floats
    ///   // If no right floats, `right_edge = containing_width`
    ///
    /// STEP 4: Return available width and left offset
    ///   // `available_width = right_edge - left_edge`
    ///   // `left_offset = left_edge`
    #[must_use]
    pub fn available_width_at(&self, _y: f32, _height: f32) -> (f32, f32) {
        todo!("Calculate available width between floats at given Y per CSS 2.1 § 9.5")
    }
}
